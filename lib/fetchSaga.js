'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

exports.default = fetchSaga;

var _reduxSaga = require('redux-saga');

var _effects = require('redux-saga/effects');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fetchService = require('./services/fetchService');

var _actions = require('./actions');

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [fetchData, fetchOnce, fetchDataLoop, fetchDataRecurring, fetchLatest, interceptOauthToken, fetchSaga].map(_regenerator2.default.mark);

/**
 * Oauth token as generated by OWIN.NET.
 * 
 */


/**
 * modelName - The key that is used to locate the request config in apis.js and also to place the result in the redux store
 * headers - (optional) An object as key/value pairs of headers to be sent with the request
 * queryParams - (optional) An object as key/value pairs to be added to query as query params
 * noStore - (optional) If true, make the request but do not store in redux. Can be used with take & friends for side effects
 * period - (optional) How often to re-fetch when used in a recurring fetch scenario
 * taskId - (optional) A pre-generated (by your application) id to be used to cancel a recurring task at a later time
 * 
 */


/**
 * oauthToken - The object representing an oAuth token
 * 
 */
var logger = void 0;
var models = void 0;
var oauthToken = void 0;

/**
 * Construct a request based on the provided action, make a request with a configurable retry,
 * and handle errors, logging and dispatching all steps.
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchData(action) {
	var _this = this;

	var tryLimit, tryCount, didFail, lastError, baseConfig, authHeaders, _headers, fetchConfig, _ref, fetchResult, timedOut;

	return _regenerator2.default.wrap(function fetchData$(_context2) {
		while (1) {
			switch (_context2.prev = _context2.next) {
				case 0:
					if (action.modelName) {
						_context2.next = 2;
						break;
					}

					throw new Error("'modelName' config parameter is required for fetchData");

				case 2:

					// Configure retry
					tryLimit = action.noRetry ? 0 : 4;
					tryCount = 0;
					didFail = void 0;
					lastError = '';

					// Run retry loop

				case 6:
					didFail = false;
					tryCount++;
					_context2.prev = 8;
					_context2.next = 11;
					return (0, _effects.put)((0, _actions.createAction)(action.noStore ? _actions2.default.TRANSIENT_FETCH_REQUESTED : _actions2.default.FETCH_REQUESTED, {
						modelName: action.modelName
					}));

				case 11:

					// Get fetch parameters from global fetch dictionary using the modelName passed in to locate them
					// Combine parameters from global dictionary with any passed in - locals override dictionary
					baseConfig = _lodash2.default.get(models, action.modelName);

					if (baseConfig) {
						_context2.next = 14;
						break;
					}

					throw new Error('Cannot find \'' + action.modelName + '\' model in model dictionary');

				case 14:
					// Avoiding pulling in a lib to do deep copy here. Hand crafted. Locally owned.
					// If body is string, pass it directly (to handle content-type: x-www-form-urlencoded)
					authHeaders = {};

					if (oauthToken) {
						authHeaders['Authorization'] = 'Bearer ' + oauthToken.access_token;
					}
					_headers = Object.assign({}, baseConfig.headers, action.headers, authHeaders);
					fetchConfig = Object.assign({}, baseConfig, {
						headers: _headers
					});

					if (action.body || baseConfig.body) {
						// If the body is a string, we are assuming it's an application/x-www-form-urlencoded
						if (typeof action.body === 'string') {
							fetchConfig.body = action.body;
						} else {
							fetchConfig.body = Object.assign({}, baseConfig.body, action.body);
						}
					}
					fetchConfig.queryParams = Object.assign({}, baseConfig.queryParams, action.queryParams);

					// substitute parameterized query path references with values from store
					// TODO: validate the path exists in the store

					if (!/{{.+}}/.test(fetchConfig.path)) {
						_context2.next = 22;
						break;
					}

					return _context2.delegateYield(_regenerator2.default.mark(function _callee() {
						var store;
						return _regenerator2.default.wrap(function _callee$(_context) {
							while (1) {
								switch (_context.prev = _context.next) {
									case 0:
										_context.next = 2;
										return (0, _effects.select)(function (store) {
											return store;
										});

									case 2:
										store = _context.sent;

										fetchConfig.path = fetchConfig.path.replace(/{{(.+?)}}/, function (_, backref) {
											return _.get(store, backref);
										});

									case 4:
									case 'end':
										return _context.stop();
								}
							}
						}, _callee, _this);
					})(), 't0', 22);

				case 22:
					_context2.next = 24;
					return (0, _effects.race)({
						fetchResult: (0, _effects.call)(_fetchService.doFetch, fetchConfig),
						timedOut: (0, _effects.call)(_reduxSaga.delay, action.timeLimit ? action.timeLimit : 3000)
					});

				case 24:
					_ref = _context2.sent;
					fetchResult = _ref.fetchResult;
					timedOut = _ref.timedOut;

					if (!(fetchResult && !(fetchResult.title && fetchResult.title === 'Error'))) {
						_context2.next = 32;
						break;
					}

					_context2.next = 30;
					return (0, _effects.put)((0, _actions.createAction)(action.noStore ? _actions2.default.TRANSIENT_FETCH_RESULT_RECEIVED : _actions2.default.FETCH_RESULT_RECEIVED, {
						data: fetchResult,
						modelName: action.modelName
					}));

				case 30:
					_context2.next = 40;
					break;

				case 32:
					if (!timedOut) {
						_context2.next = 37;
						break;
					}

					_context2.next = 35;
					return (0, _effects.put)((0, _actions.createAction)(_actions2.default.FETCH_TIMED_OUT, {
						modelName: action.modelName
					}));

				case 35:
					_context2.next = 40;
					break;

				case 37:
					_context2.next = 39;
					return (0, _effects.put)((0, _actions.createAction)(_actions2.default.FETCH_TRY_FAILED, {
						modelName: action.modelName,
						errorData: fetchResult
					}));

				case 39:
					throw new Error();

				case 40:
					_context2.next = 50;
					break;

				case 42:
					_context2.prev = 42;
					_context2.t1 = _context2['catch'](8);

					didFail = true;
					lastError = _context2.t1;
					logger('fetchData fail');
					logger(_context2.t1);
					_context2.next = 50;
					return (0, _effects.call)(_reduxSaga.delay, 2 ^ tryCount * 100);

				case 50:
					if (tryCount < tryLimit && didFail) {
						_context2.next = 6;
						break;
					}

				case 51:
					if (!(tryCount === tryLimit && didFail)) {
						_context2.next = 56;
						break;
					}

					_context2.next = 54;
					return (0, _effects.put)((0, _actions.createAction)(_actions2.default.FETCH_FAILED, { modelName: action.modelName }));

				case 54:
					logger('fetchData retry fail');
					logger(lastError);

				case 56:
				case 'end':
					return _context2.stop();
			}
		}
	}, _marked[0], this, [[8, 42]]);
}

/**
 * Call the fetchData saga exactly one time (keeping in mind fetchData has retries by default)
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchOnce(action) {
	return _regenerator2.default.wrap(function fetchOnce$(_context3) {
		while (1) {
			switch (_context3.prev = _context3.next) {
				case 0:
					_context3.next = 2;
					return (0, _effects.call)(fetchData, action);

				case 2:
				case 'end':
					return _context3.stop();
			}
		}
	}, _marked[1], this);
}

/**
 * The loop saga that makes the request every {config.period} milliseconds until
 * cancelled
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchDataLoop(action) {
	return _regenerator2.default.wrap(function fetchDataLoop$(_context4) {
		while (1) {
			switch (_context4.prev = _context4.next) {
				case 0:
					_context4.prev = 0;

				case 1:
					if (!true) {
						_context4.next = 8;
						break;
					}

					_context4.next = 4;
					return (0, _effects.call)(fetchData, action);

				case 4:
					_context4.next = 6;
					return (0, _effects.call)(_reduxSaga.delay, action.period);

				case 6:
					_context4.next = 1;
					break;

				case 8:
					_context4.prev = 8;

					(0, _effects.put)(_actions2.default.PERIODIC_TERMINATION_SUCCEEDED);
					return _context4.finish(8);

				case 11:
				case 'end':
					return _context4.stop();
			}
		}
	}, _marked[2], this, [[0,, 8, 11]]);
}

/**
 * Call the fetchData saga every {config.period} milliseconds. This saga requires the 'period' and 'taskId' properties
 * on the action parameter.
 * 
 * @param {FetchAction} action - An action with the request configuration 
 */
function fetchDataRecurring(action) {
	var bgSyncTask;
	return _regenerator2.default.wrap(function fetchDataRecurring$(_context5) {
		while (1) {
			switch (_context5.prev = _context5.next) {
				case 0:
					if (action.period) {
						_context5.next = 2;
						break;
					}

					throw new Error("'period' config parameter is required for fetchDataRecurring");

				case 2:
					if (action.taskId) {
						_context5.next = 4;
						break;
					}

					throw new Error("'taskId' config parameter is required for fetchDataRecurring");

				case 4:
					_context5.next = 6;
					return (0, _effects.fork)(fetchDataLoop, action);

				case 6:
					bgSyncTask = _context5.sent;
					_context5.next = 9;
					return (0, _effects.take)(function (action) {
						return action.type === _actions2.default.PERIODIC_TERMINATION_REQUESTED && action.taskId === action.taskId;
					});

				case 9:
					_context5.next = 11;
					return (0, _effects.cancel)(bgSyncTask);

				case 11:
				case 'end':
					return _context5.stop();
			}
		}
	}, _marked[3], this);
}

/**
 * Call the fetchData saga, ensuring that any concurrent requests are handled and only the last one is acted on
 * 
 * @param {FetchAction} action - An action with the request configuration 
 */
function fetchLatest(action) {
	return _regenerator2.default.wrap(function fetchLatest$(_context6) {
		while (1) {
			switch (_context6.prev = _context6.next) {
				case 0:
					_context6.next = 2;
					return (0, _effects.call)(fetchData, action);

				case 2:
				case 'end':
					return _context6.stop();
			}
		}
	}, _marked[4], this);
}

/**
 * Function to save an oAuth token when it is receieved via a token success action
 * Token is stored and sent in all subsequent requests via Authorization headers.
 * The oAuth token is stored in memory but not in redux.
 * 
 * @param {TokenSuccessAction} action - The action containing the oAuth token
 */
function interceptOauthToken(action) {
	return _regenerator2.default.wrap(function interceptOauthToken$(_context7) {
		while (1) {
			switch (_context7.prev = _context7.next) {
				case 0:
					oauthToken = action.oauthToken;

				case 1:
				case 'end':
					return _context7.stop();
			}
		}
	}, _marked[5], this);
}

/**
 * A default logger function that logs to the console. Used if no other logger is provided
 * 
 * @param {string} message - The message to log
 */
var consoleLogger = function consoleLogger(message) {
	console.log(message);
};

/**
 * The main saga for fetching data. Must be initialized with an object representing the models that can be fetched
 * and an API root to prepend to any partial URLs specified in the models object. A logger should normally be provided
 * as well.
 * 
 * Models object require a form as follows (with optional nested models):
 * {
 * 	fryModel: {
 * 		path: '/api/Foo'
 * 	},
 * 	groupOfModels: {
 * 		leelaModel: {
 * 			path: '/api/Bar'
 * 		},
 * 		benderModel: {
 * 			path: '/api/Baz'
 * 		}
 * 	}
 * }
 * 
 * Models are referenced in the actions.DATA_REQUESTED action by path, i.e.
 * { type: actions.DATA_REQUESTED, { modelName: 'fryModel' } }
 * -- or --
 * { type: actions.DATA_REQUESTED, { modelName: 'groupOfModels.leelaModel' } }
 * 
 * @export
 * @param {Object} modelsParam - An object indicating the APIs available in a application with which to make requests
 * @param {string} apiRootParam - A url to which partial URLs are appended (i.e.) 'https://myapp.com'
 * @param {LoggerFunction} [loggerParam=consoleLogger] - A function that accepts a string and logs it real good
 */
function fetchSaga(modelsParam, apiRootParam) {
	var loggerParam = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : consoleLogger;
	return _regenerator2.default.wrap(function fetchSaga$(_context8) {
		while (1) {
			switch (_context8.prev = _context8.next) {
				case 0:
					if (modelsParam) {
						_context8.next = 2;
						break;
					}

					throw new Error("'modelsParam' is required for fetchSaga");

				case 2:
					(0, _fetchService.setApiRoot)(apiRootParam);
					logger = loggerParam;
					models = modelsParam;

					_context8.next = 7;
					return (0, _effects.takeEvery)(_actions2.default.DATA_REQUESTED, fetchOnce);

				case 7:
					_context8.next = 9;
					return (0, _effects.takeEvery)(_actions2.default.PERIODIC_DATA_REQUESTED, fetchDataRecurring);

				case 9:
					_context8.next = 11;
					return (0, _effects.takeLatest)(_actions2.default.DATA_REQUESTED_USE_LATEST, fetchLatest);

				case 11:
					_context8.next = 13;
					return (0, _effects.takeLatest)('auth/GET_TOKEN_SUCCEEDED', interceptOauthToken);

				case 13:
					_context8.next = 15;
					return (0, _effects.takeLatest)('auth/TOKEN_REFRESH_SUCCEEDED', interceptOauthToken);

				case 15:
				case 'end':
					return _context8.stop();
			}
		}
	}, _marked[6], this);
}