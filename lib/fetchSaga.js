'use strict'

Object.defineProperty(exports, '__esModule', {
	value: true
})

var _regenerator = require('babel-runtime/regenerator')

var _regenerator2 = _interopRequireDefault(_regenerator)

exports.default = fetchSaga

var _reduxSaga = require('redux-saga')

var _effects = require('redux-saga/effects')

var _lodash = require('lodash')

var _lodash2 = _interopRequireDefault(_lodash)

var _uuid = require('uuid')

var _uuid2 = _interopRequireDefault(_uuid)

var _fetchService = require('./services/fetchService')

var _actions = require('./actions')

var _actions2 = _interopRequireDefault(_actions)

function _interopRequireDefault(obj) {
	return obj && obj.__esModule ? obj : { default: obj }
}

var _marked = [fetchData, fetchOnce, fetchDataLoop, fetchDataRecurring, fetchSaga].map(
	_regenerator2.default.mark
)

//#endregion Types

//#region Helpers

//#region Types

/**
 * Oauth token as generated by OWIN.NET.
 * 
 */

/**
 * modelName - The key that is used to locate the request config in apis.js and also to place the result in the redux store
 * method - (optional) The HTTP Method to use for the fetch. Otherwise will use the method set in apis.js, or 'GET'
 * headers - (optional) An object as key/value pairs of headers to be sent with the request
 * queryParams - (optional) An object as key/value pairs to be added to query as query params
 * pathParams - (optional) An array of values to be replaced in the fetch path using pattern matching, in order, "/collection/{}/subcollection/{}" => "/collection/1/subcollection/2"
 * noStore - (optional) If true, make the request but do not store in redux. Can be used with take & friends for side effects
 * period - (optional) How often to re-fetch when used in a recurring fetch scenario
 * taskId - (optional) A pre-generated (by your application) id to be used to cancel a recurring task at a later time
 * noRetry - (optional)  will prevent the use of the default logarithmic backoff retry strategy
 * timeLimit - (optional) number that will specify the timeout for a single attempt at a request. Defaults to 3000ms
 * guid - (optional) A pre-generated (by your application) GUID that will be attached to the fetchResult.data, to be stored in redux and used to match
 * contentType - (optional) the contentType to be set in the header. If not set, the default value is `application/json`
 */
var getState = function getState(state) {
	return state
}

var matchesTerminationAction = function matchesTerminationAction(incomingAction, fetchAction) {
	return (
		incomingAction.type === _actions2.default.PERIODIC_TERMINATION_REQUESTED &&
		incomingAction.taskId === fetchAction.taskId
	)
}

var takeMatchesTerminationAction = function takeMatchesTerminationAction(action) {
	return function(incomingAction) {
		return matchesTerminationAction(incomingAction, action)
	}
}

var defaultTokenAccessFunction = function defaultTokenAccessFunction() {
	return undefined
}

var defaultErrorFunction = function defaultErrorFunction(message) {}

/**
 * A default logger function that logs to the console. Used if no other logger is provided
 * 
 * @param {string} message - The message to log
 */
var defaultLogger = function defaultLogger(message) {
	console.debug(message)
}

//#endregion Helpers

//#region Local Variables

var logger = void 0
var models = void 0
var tokenAccessFunction = void 0
var errorFunction = void 0

//#endregion Shared Variables

/**
 * Prepare fetchConfig to pass to fetchService. Also set up state
 * to handle response correctly.
 * 
 * @param {Object} model - The model selected from the models object
 * @param {FetchAction} action - The action dispatched by the client
 * @param {Object} models - The entire models object, passed in for testability
 */
function prepareFetch(model, action, models) {
	var modelConfig = _lodash2.default.merge({}, model._config)
	var fetchConfig = _lodash2.default.merge({}, modelConfig.fetch, {
		headers: _lodash2.default.merge({}, action.headers),
		queryParams: _lodash2.default.merge({}, action.queryParams)
	})

	// set "method" if defined
	if (action.method && typeof action.method === 'string') {
		fetchConfig.method = action.method
	}

	// set or merge "body"
	// If the body is a string, we are assuming it's an application/x-www-form-urlencoded
	if (action.body && (typeof action.body === 'string' || action.body instanceof FormData)) {
		fetchConfig.body = action.body
		fetchConfig.contentType = 'application/x-www-form-urlencoded'
	} else if (fetchConfig.body || action.body) {
		var isBodyArray =
			(fetchConfig.body && _lodash2.default.isArray(fetchConfig.body)) ||
			(action.body && _lodash2.default.isArray(action.body))
		fetchConfig.body = isBodyArray
			? _lodash2.default.union([], fetchConfig.body, action.body)
			: _lodash2.default.merge({}, fetchConfig.body, action.body)
	}

	// set "contentType" if defined, overriding the default application/x-www-form-urlencoded
	// that may have been set previously
	if (action.contentType && typeof action.contentType === 'string') {
		fetchConfig.contentType = action.contentType
	}

	var modelName = action.modelName
	var isCollectionItemFetch = false
	var isCollectionItemCreate = false
	var isUrlValid = true
	var pathParams = action.pathParams || []

	// collection "fetchConfig.path" and "modelName"
	var modelNameLevels = modelName.split('.')
	var lastModelLevel = models
	var modelLevels = modelNameLevels.map(function(levelName) {
		var modelLevel = _lodash2.default.get(lastModelLevel, levelName)
		lastModelLevel = modelLevel
		return modelLevel
	})
	var isAnyLevelCollection = modelLevels.some(function(level) {
		return level._config && level._config.isCollection
	})
	if (isAnyLevelCollection) {
		// construct modelName and path
		if (modelNameLevels.length > 1) {
			modelLevels.forEach(function(modelLevel, index) {
				var levelName = modelNameLevels[index]
				var currentModelConfig = _lodash2.default.merge({}, modelLevel._config)
				var currentFetchConfig = _lodash2.default.merge({}, currentModelConfig.fetch)
				if (index === 0) {
					fetchConfig.path = currentFetchConfig.path || '/api/' + levelName
					modelName = levelName
					return
				}
				fetchConfig.path = fetchConfig.path + '/{:id}/' + (currentFetchConfig.path || levelName)
				modelName = modelName + '.{:id}.' + levelName
			})
		} else if (!fetchConfig.path) {
			fetchConfig.path = '/api/' + modelName
		}
		// determine if we need to add pathParam hooks
		var pathLevels = (fetchConfig.path.match(/{:id}/g) || []).length
		// GET, PUT, PATCH, DELETE => append '/{:id}'
		isCollectionItemFetch = modelConfig.isCollection && pathParams.length > pathLevels
		// POST
		isCollectionItemCreate = modelConfig.isCollection && fetchConfig.method === 'POST'

		// insert pathParam hooks into path and modelName
		// track collection item requests by id (update, delete) or guid (create)
		if (isCollectionItemFetch && !isCollectionItemCreate) {
			fetchConfig.path = fetchConfig.path + '/{:id}'
			modelName = modelName + '.{:id}'
		} else if (isCollectionItemCreate) {
			modelName = modelName + '.' + (action.guid || _uuid2.default.v4())
		}
	}
	// substitute any pathParams in path, e.g. /api/group/{:id}
	if (/{:.+}/.test(fetchConfig.path)) {
		var index = 0
		fetchConfig.path = fetchConfig.path.replace(/{:(.+?)}/g, function(matches, backref) {
			var value = pathParams[index]
			if (value === undefined || value === null) {
				isUrlValid = false
			}
			index++
			return value
		})
	}

	// substitute any pathParams in modelName, e.g. groups.{:id}
	if (/{:.+}/.test(modelName)) {
		var _index = 0
		modelName = modelName.replace(/{:(.+?)}/g, function(matches, backref) {
			var value = pathParams[_index]
			if (value === undefined || value === null) {
				isUrlValid = false
			}
			_index++
			return value
		})
	}

	return {
		fetchConfig: fetchConfig,
		modelConfig: modelConfig,
		modelName: modelName,
		isCollectionItemFetch: isCollectionItemFetch,
		isCollectionItemCreate: isCollectionItemCreate,
		isUrlValid: isUrlValid,
		pathParams: pathParams
	}
}

/**
 * Construct a request based on the provided action, make a request with a configurable retry,
 * and handle errors, logging and dispatching all steps.
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchData(action) {
	var _this = this

	var model,
		result,
		fetchConfig,
		modelConfig,
		pathParams,
		modelName,
		isCollectionItemFetch,
		isCollectionItemCreate,
		isUrlValid,
		store,
		tryLimit,
		tryCount,
		didFail,
		lastFetchError,
		lastError,
		_errorData

	return _regenerator2.default.wrap(
		function fetchData$(_context2) {
			while (1) {
				switch ((_context2.prev = _context2.next)) {
					case 0:
						if (!(!action || !action.modelName)) {
							_context2.next = 2
							break
						}

						throw new Error("'modelName' config parameter is required for fetchData")

					case 2:
						// Get fetch parameters from global fetch dictionary using the modelName passed in to locate them
						// Combine parameters from global dictionary with any passed in - locals override dictionary
						model = _lodash2.default.get(models, action.modelName)

						if (model) {
							_context2.next = 5
							break
						}

						throw new Error("Cannot find '" + action.modelName + "' model in model dictionary")

					case 5:
						result = prepareFetch(model, action, models)
						;(fetchConfig = result.fetchConfig),
							(modelConfig = result.modelConfig),
							(pathParams = result.pathParams)
						;(modelName = result.modelName),
							(isCollectionItemFetch = result.isCollectionItemFetch),
							(isCollectionItemCreate = result.isCollectionItemCreate),
							(isUrlValid = result.isUrlValid)

						// TODO: Figure out how to move this into prepareFetch() without causing the
						// carefully constructed tower of yield()s in the tests from crashing down
						// substitute any path parameters from the redux store, e.g. '{{apiRoot}}/groups'

						if (!/{{.+}}/.test(fetchConfig.path)) {
							_context2.next = 13
							break
						}

						_context2.next = 11
						return (0, _effects.select)(getState)

					case 11:
						store = _context2.sent

						fetchConfig.path = fetchConfig.path.replace(/{{(.+?)}}/, function(matches, backref) {
							var value = _lodash2.default.get(store, backref)
							if (value === undefined || value === null) {
								isUrlValid = false
							}
							return value
						})

					case 13:
						if (isUrlValid) {
							_context2.next = 17
							break
						}

						_context2.next = 16
						return (0, _effects.put)(
							(0, _actions.createAction)(
								action.noStore
									? _actions2.default.TRANSIENT_FETCH_FAILED
									: _actions2.default.FETCH_FAILED,
								{
									modelName: action.modelName,
									guid: action.guid,
									errorData: 'Invalid URL'
								}
							)
						)

					case 16:
						return _context2.abrupt('return')

					case 17:
						// Configure retry
						tryLimit = action.noRetry ? 1 : 4
						tryCount = 0
						didFail = false
						lastFetchError = void 0
						lastError = void 0
					// Run retry loop

					case 22:
						didFail = false
						tryCount++
						// Indicate fetch action has begun
						_context2.next = 26
						return (0, _effects.put)(
							(0, _actions.createAction)(
								action.noStore
									? _actions2.default.TRANSIENT_FETCH_REQUESTED
									: _actions2.default.FETCH_REQUESTED,
								{
									modelName: modelName,
									guid: action.guid
								}
							)
						)

					case 26:
						_context2.prev = 26
						return _context2.delegateYield(
							_regenerator2.default.mark(function _callee() {
								var oauthToken,
									_ref,
									fetchResult,
									timedOutResult,
									storeAction,
									data,
									fetchedAt,
									modelNameLevels

								return _regenerator2.default.wrap(
									function _callee$(_context) {
										while (1) {
											switch ((_context.prev = _context.next)) {
												case 0:
													_context.next = 2
													return (0, _effects.call)(tokenAccessFunction, action.modelName)

												case 2:
													oauthToken = _context.sent

													if (oauthToken && oauthToken.access_token) {
														fetchConfig.headers['Authorization'] =
															'Bearer ' + oauthToken.access_token
													}
													_context.next = 6
													return (0, _effects.race)({
														fetchResult: (0, _effects.call)(_fetchService.doFetch, fetchConfig),
														timedOutResult: (0, _effects.call)(
															_reduxSaga.delay,
															action.timeLimit ? action.timeLimit : 30000
														)
													})

												case 6:
													_ref = _context.sent
													fetchResult = _ref.fetchResult
													timedOutResult = _ref.timedOutResult

													if (!(fetchResult && fetchResult.ok)) {
														_context.next = 27
														break
													}

													storeAction = action.noStore
														? _actions2.default.TRANSIENT_FETCH_RESULT_RECEIVED
														: _actions2.default.FETCH_RESULT_RECEIVED
													data = fetchResult.data

													if (modelConfig.isCollection) {
														if (fetchConfig.method === 'DELETE') {
															storeAction = _actions2.default.KEY_REMOVAL_REQUESTED
															data = {}
														} else if (isCollectionItemFetch || isCollectionItemCreate) {
															data = fetchResult.data
														} else {
															fetchedAt = new Date()
															// convert to a key-value collection
															// handles arrays or objects
															// set item metadata

															data = Object.keys(fetchResult.data).reduce(function(out, key) {
																var item = fetchResult.data[key]
																out[item.id] = _lodash2.default.merge({}, item, {
																	_metadata: {
																		isFetching: false,
																		hasError: false,
																		timedOut: false,
																		fetchedAt: fetchedAt
																	}
																})
																return out
															}, {})
														}
													}

													// attach guid to result
													if (action.guid && _lodash2.default.isPlainObject(data)) {
														data.guid = action.guid
													}

													// POST new collection item

													if (!isCollectionItemCreate) {
														_context.next = 23
														break
													}

													modelNameLevels = modelName.split('.')
													// remove guid

													modelNameLevels.pop()
													// add by new result's id
													_context.next = 19
													return (0, _effects.put)(
														(0, _actions.createAction)(storeAction, {
															modelName: modelNameLevels.join('.') + '.' + data.id,
															guid: action.guid,
															data: data
														})
													)

												case 19:
													_context.next = 21
													return (0, _effects.put)(
														(0, _actions.createAction)(_actions2.default.KEY_REMOVAL_REQUESTED, {
															modelName: modelName
														})
													)

												case 21:
													_context.next = 25
													break

												case 23:
													_context.next = 25
													return (0, _effects.put)(
														(0, _actions.createAction)(storeAction, {
															modelName: modelName,
															guid: action.guid,
															data: data
														})
													)

												case 25:
													_context.next = 29
													break

												case 27:
													// combine fetchResult with didTimeOut
													lastFetchError = {
														modelName: modelName,
														errorData: _lodash2.default.merge(
															{
																didTimeOut: !!timedOutResult
															},
															fetchResult && fetchResult.data ? fetchResult.data : {}
														)
													}
													throw new Error(JSON.stringify(lastFetchError))

												case 29:
												case 'end':
													return _context.stop()
											}
										}
									},
									_callee,
									_this
								)
							})(),
							't0',
							28
						)

					case 28:
						_context2.next = 42
						break

					case 30:
						_context2.prev = 30
						_context2.t1 = _context2['catch'](26)
						_errorData = lastFetchError ? lastFetchError.errorData : null
						_context2.next = 35
						return (0, _effects.put)(
							(0, _actions.createAction)(
								_actions2.default.TRY_FETCH_FAILED,
								_lodash2.default.merge({ modelName: modelName, guid: action.guid }, lastFetchError)
							)
						)

					case 35:
						// Don't do anything with 401 errors
						// And some errors don't have fetch results associated with them
						if (_errorData && _errorData.code ? _errorData.code !== 401 : true) {
							errorFunction(_context2.t1.message)
						}
						logger('fetchData fail')
						logger(_context2.t1)

						didFail = true
						lastError = _context2.t1
						_context2.next = 42
						return (0, _effects.call)(_reduxSaga.delay, 2 ^ (tryCount * 100))

					case 42:
						if (tryCount < tryLimit && didFail) {
							_context2.next = 22
							break
						}

					case 43:
						if (!(tryCount === tryLimit && didFail)) {
							_context2.next = 48
							break
						}

						_context2.next = 46
						return (0, _effects.put)(
							(0, _actions.createAction)(
								action.noStore
									? _actions2.default.TRANSIENT_FETCH_FAILED
									: _actions2.default.FETCH_FAILED,
								_lodash2.default.merge(
									{
										modelName: modelName,
										guid: action.guid
									},
									lastFetchError
								)
							)
						)

					case 46:
						logger('fetchData retry fail')
						logger(lastError)

					case 48:
					case 'end':
						return _context2.stop()
				}
			}
		},
		_marked[0],
		this,
		[[26, 30]]
	)
}

/**
 * Call the fetchData saga exactly one time (keeping in mind fetchData has retries by default)
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchOnce(action) {
	return _regenerator2.default.wrap(
		function fetchOnce$(_context3) {
			while (1) {
				switch ((_context3.prev = _context3.next)) {
					case 0:
						_context3.next = 2
						return (0, _effects.call)(fetchData, action)

					case 2:
					case 'end':
						return _context3.stop()
				}
			}
		},
		_marked[1],
		this
	)
}

/**
 * The loop saga that makes the request every {config.period} milliseconds until
 * cancelled
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchDataLoop(action) {
	return _regenerator2.default.wrap(
		function fetchDataLoop$(_context4) {
			while (1) {
				switch ((_context4.prev = _context4.next)) {
					case 0:
						_context4.prev = 0

					case 1:
						if (!true) {
							_context4.next = 8
							break
						}

						_context4.next = 4
						return (0, _effects.call)(fetchData, action)

					case 4:
						_context4.next = 6
						return (0, _effects.call)(_reduxSaga.delay, action.period)

					case 6:
						_context4.next = 1
						break

					case 8:
						_context4.next = 15
						break

					case 10:
						_context4.prev = 10
						_context4.t0 = _context4['catch'](0)

						errorFunction(_context4.t0.message)
						logger('fetchDataLoop fail')
						logger(_context4.t0)

					case 15:
						_context4.prev = 15
						_context4.next = 18
						return (0, _effects.cancelled)()

					case 18:
						if (!_context4.sent) {
							_context4.next = 21
							break
						}

						_context4.next = 21
						return (0, _effects.put)(
							(0, _actions.createAction)(_actions2.default.PERIODIC_TERMINATION_SUCCEEDED, {
								modelName: action.modelName
							})
						)

					case 21:
						return _context4.finish(15)

					case 22:
					case 'end':
						return _context4.stop()
				}
			}
		},
		_marked[2],
		this,
		[[0, 10, 15, 22]]
	)
}

/**
 * Call the fetchData saga every {config.period} milliseconds. This saga requires the 'period' and 'taskId' properties
 * on the action parameter.
 * 
 * @param {FetchAction} action - An action with the request configuration 
 */
function fetchDataRecurring(action) {
	var bgSyncTask
	return _regenerator2.default.wrap(
		function fetchDataRecurring$(_context5) {
			while (1) {
				switch ((_context5.prev = _context5.next)) {
					case 0:
						if (!(!action || !action.period)) {
							_context5.next = 2
							break
						}

						throw new Error("'period' config parameter is required for fetchDataRecurring")

					case 2:
						if (!(!action || !action.taskId)) {
							_context5.next = 4
							break
						}

						throw new Error("'taskId' config parameter is required for fetchDataRecurring")

					case 4:
						_context5.next = 6
						return (0, _effects.fork)(fetchDataLoop, action)

					case 6:
						bgSyncTask = _context5.sent
						_context5.next = 9
						return (0, _effects.take)(takeMatchesTerminationAction(action))

					case 9:
						_context5.next = 11
						return (0, _effects.cancel)(bgSyncTask)

					case 11:
					case 'end':
						return _context5.stop()
				}
			}
		},
		_marked[3],
		this
	)
}

/**
 * The main saga for fetching data. Must be initialized with an object representing the models that can be fetched
 * and an API root to prepend to any partial URLs specified in the models object. A logger should normally be provided
 * as well.
 * 
 * Models object require a form as follows (with optional nested models):
 * {
 * 	fryModel: {
 * 		path: '/api/Foo'
 * 	},
 * 	groupOfModels: {
 * 		leelaModel: {
 * 			path: '/api/Bar'
 * 		},
 * 		benderModel: {
 * 			path: '/api/Baz'
 * 		}
 * 	}
 * }
 * 
 * Models are referenced in the actions.DATA_REQUESTED action by path, i.e.
 * { type: actions.DATA_REQUESTED, { modelName: 'fryModel' } }
 * -- or --
 * { type: actions.DATA_REQUESTED, { modelName: 'groupOfModels.leelaModel' } }
 * 
 * @export
 * @param {Object} modelsParam - An object indicating the APIs available in a application with which to make requests
 * @param {string} apiRootParam - A url to which partial URLs are appended (i.e.) 'https://myapp.com'
 * @param {TokenAccessFunction} [tokenAccessParam=defaultTokenAccessFunction] - function that returns an optional OAuth token
 * @param {ErrorFunction} [errorParam=defaultErrorFunction]  - A function to perform on errors
 * @param {LoggerFunction} [loggerParam=defaultLogger] - A function that accepts a string and logs it real good
 */
function fetchSaga(modelsParam, apiRootParam) {
	var tokenAccessFunctionParam =
		arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultTokenAccessFunction
	var errorFunctionParam =
		arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultErrorFunction
	var loggerParam =
		arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultLogger
	return _regenerator2.default.wrap(
		function fetchSaga$(_context6) {
			while (1) {
				switch ((_context6.prev = _context6.next)) {
					case 0:
						if (modelsParam) {
							_context6.next = 2
							break
						}

						throw new Error("'modelsParam' is required for fetchSaga")

					case 2:
						;(0, _fetchService.setApiRoot)(apiRootParam)
						logger = loggerParam
						logger('logger set to ' + logger.name)
						models = modelsParam
						errorFunction = errorFunctionParam
						tokenAccessFunction = tokenAccessFunctionParam

						_context6.next = 10
						return (0, _effects.takeEvery)(_actions2.default.DATA_REQUESTED, fetchOnce)

					case 10:
						_context6.next = 12
						return (0, _effects.takeEvery)(
							_actions2.default.PERIODIC_DATA_REQUESTED,
							fetchDataRecurring
						)

					case 12:
						_context6.next = 14
						return (0, _effects.takeLatest)(_actions2.default.DATA_REQUESTED_USE_LATEST, fetchOnce)

					case 14:
					case 'end':
						return _context6.stop()
				}
			}
		},
		_marked[4],
		this
	)
}
