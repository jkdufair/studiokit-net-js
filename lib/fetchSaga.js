'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

exports.default = fetchSaga;

var _reduxSaga = require('redux-saga');

var _effects = require('redux-saga/effects');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fetchService = require('./services/fetchService');

var _actions = require('./actions');

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [fetchData, fetchOnce, fetchDataLoop, fetchDataRecurring, fetchSaga].map(_regenerator2.default.mark);

/**
 * Oauth token as generated by OWIN.NET.
 * 
 */


/**
 * modelName - The key that is used to locate the request config in apis.js and also to place the result in the redux store
 * headers - (optional) An object as key/value pairs of headers to be sent with the request
 * queryParams - (optional) An object as key/value pairs to be added to query as query params
 * noStore - (optional) If true, make the request but do not store in redux. Can be used with take & friends for side effects
 * period - (optional) How often to re-fetch when used in a recurring fetch scenario
 * taskId - (optional) A pre-generated (by your application) id to be used to cancel a recurring task at a later time
 * 
 */


/**
 * oauthToken - The object representing an oAuth token
 * 
 */
var logger = void 0;
var models = void 0;
var oauthToken = void 0;

/**
 * Construct a request based on the provided action, make a request with a configurable retry,
 * and handle errors, logging and dispatching all steps.
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchData(action) {
	var tryLimit, tryCount, didFail, lastError, baseConfig, authHeaders, headers, fetchConfig, store, _ref, fetchResult, timedOut;

	return _regenerator2.default.wrap(function fetchData$(_context) {
		while (1) {
			switch (_context.prev = _context.next) {
				case 0:
					if (!(!action || !action.modelName)) {
						_context.next = 2;
						break;
					}

					throw new Error("'modelName' config parameter is required for fetchData");

				case 2:

					// Configure retry
					tryLimit = action.noRetry ? 0 : 4;
					tryCount = 0;
					didFail = void 0;
					lastError = '';

					// Get fetch parameters from global fetch dictionary using the modelName passed in to locate them
					// Combine parameters from global dictionary with any passed in - locals override dictionary

					baseConfig = _lodash2.default.get(models, action.modelName);

					if (baseConfig) {
						_context.next = 9;
						break;
					}

					throw new Error('Cannot find \'' + action.modelName + '\' model in model dictionary');

				case 9:
					// Avoiding pulling in a lib to do deep copy here. Hand crafted. Locally owned.
					// If body is string, pass it directly (to handle contenttype: x-www-form-urlencoded)
					authHeaders = {};

					if (oauthToken) {
						authHeaders['Authorization'] = 'Bearer ' + oauthToken.access_token;
					}
					headers = Object.assign({}, baseConfig.headers, action.headers, authHeaders);
					fetchConfig = Object.assign({}, baseConfig, {
						headers: headers
					});

					if (action.body || baseConfig.body) {
						// If the body is a string, we are assuming it's an application/x-www-form-urlencoded
						if (typeof action.body === 'string') {
							fetchConfig.body = action.body;
						} else {
							fetchConfig.body = Object.assign({}, baseConfig.body, action.body);
						}
					}
					fetchConfig.queryParams = Object.assign({}, baseConfig.queryParams, action.queryParams);

					// substitute parameterized query path references with values from store
					// TODO: validate the path exists in the store

					if (!/{{.+}}/.test(fetchConfig.path)) {
						_context.next = 20;
						break;
					}

					_context.next = 18;
					return (0, _effects.select)(function (state) {
						return state;
					});

				case 18:
					store = _context.sent;

					fetchConfig.path = fetchConfig.path.replace(/{{(.+?)}}/, function (matches, backref) {
						return _lodash2.default.get(store, backref);
					});

				case 20:
					didFail = false;
					tryCount++;
					// Indicate fetch action has begun
					_context.next = 24;
					return (0, _effects.put)((0, _actions.createAction)(action.noStore ? _actions2.default.TRANSIENT_FETCH_REQUESTED : _actions2.default.FETCH_REQUESTED, {
						modelName: action.modelName
					}));

				case 24:
					_context.prev = 24;
					_context.next = 27;
					return (0, _effects.race)({
						fetchResult: (0, _effects.call)(_fetchService.doFetch, fetchConfig),
						timedOut: (0, _effects.call)(_reduxSaga.delay, action.timeLimit ? action.timeLimit : 3000)
					});

				case 27:
					_ref = _context.sent;
					fetchResult = _ref.fetchResult;
					timedOut = _ref.timedOut;

					if (!(fetchResult && !(fetchResult.title && fetchResult.title === 'Error'))) {
						_context.next = 35;
						break;
					}

					_context.next = 33;
					return (0, _effects.put)((0, _actions.createAction)(action.noStore ? _actions2.default.TRANSIENT_FETCH_RESULT_RECEIVED : _actions2.default.FETCH_RESULT_RECEIVED, {
						data: fetchResult,
						modelName: action.modelName
					}));

				case 33:
					_context.next = 44;
					break;

				case 35:
					if (!timedOut) {
						_context.next = 41;
						break;
					}

					_context.next = 38;
					return (0, _effects.put)((0, _actions.createAction)(_actions2.default.FETCH_TIMED_OUT, {
						modelName: action.modelName
					}));

				case 38:
					throw new Error();

				case 41:
					_context.next = 43;
					return (0, _effects.put)((0, _actions.createAction)(_actions2.default.FETCH_TRY_FAILED, {
						modelName: action.modelName,
						errorData: fetchResult
					}));

				case 43:
					throw new Error();

				case 44:
					_context.next = 54;
					break;

				case 46:
					_context.prev = 46;
					_context.t0 = _context['catch'](24);

					didFail = true;
					lastError = _context.t0;
					logger('fetchData fail');
					logger(_context.t0);
					_context.next = 54;
					return (0, _effects.call)(_reduxSaga.delay, 2 ^ tryCount * 100);

				case 54:
					if (tryCount < tryLimit && didFail) {
						_context.next = 20;
						break;
					}

				case 55:
					if (!(tryCount === tryLimit && didFail)) {
						_context.next = 60;
						break;
					}

					_context.next = 58;
					return (0, _effects.put)((0, _actions.createAction)(_actions2.default.FETCH_FAILED, { modelName: action.modelName }));

				case 58:
					logger('fetchData retry fail');
					logger(lastError);

				case 60:
				case 'end':
					return _context.stop();
			}
		}
	}, _marked[0], this, [[24, 46]]);
}

/**
 * Call the fetchData saga exactly one time (keeping in mind fetchData has retries by default)
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchOnce(action) {
	return _regenerator2.default.wrap(function fetchOnce$(_context2) {
		while (1) {
			switch (_context2.prev = _context2.next) {
				case 0:
					_context2.next = 2;
					return (0, _effects.call)(fetchData, action);

				case 2:
				case 'end':
					return _context2.stop();
			}
		}
	}, _marked[1], this);
}

/**
 * The loop saga that makes the request every {config.period} milliseconds until
 * cancelled
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchDataLoop(action) {
	return _regenerator2.default.wrap(function fetchDataLoop$(_context3) {
		while (1) {
			switch (_context3.prev = _context3.next) {
				case 0:
					_context3.prev = 0;

				case 1:
					if (!true) {
						_context3.next = 8;
						break;
					}

					_context3.next = 4;
					return (0, _effects.call)(fetchData, action);

				case 4:
					_context3.next = 6;
					return (0, _effects.call)(_reduxSaga.delay, action.period);

				case 6:
					_context3.next = 1;
					break;

				case 8:
					_context3.prev = 8;
					_context3.next = 11;
					return (0, _effects.put)((0, _actions.createAction)(_actions2.default.PERIODIC_TERMINATION_SUCCEEDED, action));

				case 11:
					return _context3.finish(8);

				case 12:
				case 'end':
					return _context3.stop();
			}
		}
	}, _marked[2], this, [[0,, 8, 12]]);
}

function matchesTerminationAction(incomingAction, fetchAction) {
	return incomingAction.type === _actions2.default.PERIODIC_TERMINATION_REQUESTED && incomingAction.taskId === fetchAction.taskId;
}

/**
 * Call the fetchData saga every {config.period} milliseconds. This saga requires the 'period' and 'taskId' properties
 * on the action parameter.
 * 
 * @param {FetchAction} action - An action with the request configuration 
 */
function fetchDataRecurring(action) {
	var bgSyncTask;
	return _regenerator2.default.wrap(function fetchDataRecurring$(_context4) {
		while (1) {
			switch (_context4.prev = _context4.next) {
				case 0:
					if (!(!action || !action.period)) {
						_context4.next = 2;
						break;
					}

					throw new Error("'period' config parameter is required for fetchDataRecurring");

				case 2:
					if (!(!action || !action.taskId)) {
						_context4.next = 4;
						break;
					}

					throw new Error("'taskId' config parameter is required for fetchDataRecurring");

				case 4:
					_context4.next = 6;
					return (0, _effects.fork)(fetchDataLoop, action);

				case 6:
					bgSyncTask = _context4.sent;
					_context4.next = 9;
					return (0, _effects.take)(function (incomingAction) {
						return matchesTerminationAction(incomingAction, action);
					});

				case 9:
					_context4.next = 11;
					return (0, _effects.cancel)(bgSyncTask);

				case 11:
				case 'end':
					return _context4.stop();
			}
		}
	}, _marked[3], this);
}

/**
 * Function to save an oAuth token when it is receieved via a token success action
 * Token is stored and sent in all subsequent requests via Authorization headers.
 * The oAuth token is stored in memory but not in redux.
 * 
 * @param {TokenSuccessAction} action - The action containing the oAuth token
 */
function interceptOauthToken(action) {
	oauthToken = action.oauthToken;
}

/**
 * A default logger function that logs to the console. Used if no other logger is provided
 * 
 * @param {string} message - The message to log
 */
var consoleLogger = function consoleLogger(message) {
	console.log(message);
};

/**
 * The main saga for fetching data. Must be initialized with an object representing the models that can be fetched
 * and an API root to prepend to any partial URLs specified in the models object. A logger should normally be provided
 * as well.
 * 
 * Models object require a form as follows (with optional nested models):
 * {
 * 	fryModel: {
 * 		path: '/api/Foo'
 * 	},
 * 	groupOfModels: {
 * 		leelaModel: {
 * 			path: '/api/Bar'
 * 		},
 * 		benderModel: {
 * 			path: '/api/Baz'
 * 		}
 * 	}
 * }
 * 
 * Models are referenced in the actions.DATA_REQUESTED action by path, i.e.
 * { type: actions.DATA_REQUESTED, { modelName: 'fryModel' } }
 * -- or --
 * { type: actions.DATA_REQUESTED, { modelName: 'groupOfModels.leelaModel' } }
 * 
 * @export
 * @param {Object} modelsParam - An object indicating the APIs available in a application with which to make requests
 * @param {string} apiRootParam - A url to which partial URLs are appended (i.e.) 'https://myapp.com'
 * @param {LoggerFunction} [loggerParam=consoleLogger] - A function that accepts a string and logs it real good
 */
function fetchSaga(modelsParam, apiRootParam) {
	var loggerParam = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : consoleLogger;
	return _regenerator2.default.wrap(function fetchSaga$(_context5) {
		while (1) {
			switch (_context5.prev = _context5.next) {
				case 0:
					if (modelsParam) {
						_context5.next = 2;
						break;
					}

					throw new Error("'modelsParam' is required for fetchSaga");

				case 2:
					(0, _fetchService.setApiRoot)(apiRootParam);
					logger = loggerParam;
					logger('logger set to ' + logger.name);
					models = modelsParam;

					_context5.next = 8;
					return (0, _effects.takeEvery)(_actions2.default.DATA_REQUESTED, fetchOnce);

				case 8:
					_context5.next = 10;
					return (0, _effects.takeEvery)(_actions2.default.PERIODIC_DATA_REQUESTED, fetchDataRecurring);

				case 10:
					_context5.next = 12;
					return (0, _effects.takeLatest)(_actions2.default.DATA_REQUESTED_USE_LATEST, fetchOnce);

				case 12:
					_context5.next = 14;
					return (0, _effects.takeLatest)('auth/GET_TOKEN_SUCCEEDED', interceptOauthToken);

				case 14:
					_context5.next = 16;
					return (0, _effects.takeLatest)('auth/TOKEN_REFRESH_SUCCEEDED', interceptOauthToken);

				case 16:
				case 'end':
					return _context5.stop();
			}
		}
	}, _marked[4], this);
}