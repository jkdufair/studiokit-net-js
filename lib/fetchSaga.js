'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = fetchSaga;

var _reduxSaga = require('redux-saga');

var _effects = require('redux-saga/effects');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fetchService = require('./services/fetchService');

var _actions = require('./actions');

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [fetchData, fetchOnce, fetchDataLoop, fetchDataRecurring, fetchLatest, interceptOauthToken, fetchSaga].map(_regenerator2.default.mark);

/**
 * Oauth token as generated by OWIN.NET.
 * 
 */


/**
 * modelName - The key that is used to locate the request config in apis.js and also to place the result in the redux store
 * headers - (optional) An object as key/value pairs of headers to be sent with the request
 * queryParams - (optional) An object as key/value pairs to be added to query as query params
 * noStore - (optional) If true, make the request but do not store in redux. Can be used with take & friends for side effects
 * period - (optional) How often to re-fetch when used in a recurring fetch scenario
 * taskId - (optional) A pre-generated (by your application) id to be used to cancel a recurring task at a later time
 * 
 */


/**
 * oauthToken - The object representing an oAuth token
 * 
 */
var logger = void 0;
var models = void 0;
var oauthToken = void 0;

/**
 * Construct a request based on the provided action, make a request with a configurable retry,
 * and handle errors, logging and dispatching all steps.
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchData(action) {
	var _this = this;

	var tryLimit, tryCount, didFail, lastError, baseConfig, authHeaders, _headers, fetchConfig, _ref, fetchResult, timedOut;

	return _regenerator2.default.wrap(function fetchData$(_context2) {
		while (1) {
			switch (_context2.prev = _context2.next) {
				case 0:
					if (action.modelName) {
						_context2.next = 2;
						break;
					}

					throw new Error("'modelName' config parameter is required for fetchData");

				case 2:

					// Configure retry
					tryLimit = action.noRetry ? 0 : 4;
					tryCount = 0;
					didFail = void 0;
					lastError = '';

					// Run retry loop

				case 6:
					didFail = false;
					tryCount++;
					_context2.prev = 8;
					_context2.next = 11;
					return _get__('put')(_get__('createAction')(action.noStore ? _get__('actions').TRANSIENT_FETCH_REQUESTED : _get__('actions').FETCH_REQUESTED, {
						modelName: action.modelName
					}));

				case 11:

					// Get fetch parameters from global fetch dictionary using the modelName passed in to locate them
					// Combine parameters from global dictionary with any passed in - locals override dictionary
					baseConfig = _get__('_').get(_get__('models'), action.modelName);

					if (baseConfig) {
						_context2.next = 14;
						break;
					}

					throw new Error('Cannot find \'' + action.modelName + '\' model in model dictionary');

				case 14:
					// Avoiding pulling in a lib to do deep copy here. Hand crafted. Locally owned.
					// If body is string, pass it directly (to handle content-type: x-www-form-urlencoded)
					authHeaders = {};

					if (_get__('oauthToken')) {
						authHeaders['Authorization'] = 'Bearer ' + _get__('oauthToken').access_token;
					}
					_headers = Object.assign({}, baseConfig.headers, action.headers, authHeaders);
					fetchConfig = Object.assign({}, baseConfig, {
						headers: _headers
					});

					if (action.body || baseConfig.body) {
						// If the body is a string, we are assuming it's an application/x-www-form-urlencoded
						if (typeof action.body === 'string') {
							fetchConfig.body = action.body;
						} else {
							fetchConfig.body = Object.assign({}, baseConfig.body, action.body);
						}
					}
					fetchConfig.queryParams = Object.assign({}, baseConfig.queryParams, action.queryParams);

					// substitute parameterized query path references with values from store
					// TODO: validate the path exists in the store

					if (!/{{.+}}/.test(fetchConfig.path)) {
						_context2.next = 22;
						break;
					}

					return _context2.delegateYield(_regenerator2.default.mark(function _callee() {
						var store;
						return _regenerator2.default.wrap(function _callee$(_context) {
							while (1) {
								switch (_context.prev = _context.next) {
									case 0:
										_context.next = 2;
										return _get__('select')(function (store) {
											return store;
										});

									case 2:
										store = _context.sent;

										fetchConfig.path = fetchConfig.path.replace(/{{(.+?)}}/, function (_, backref) {
											return _.get(store, backref);
										});

									case 4:
									case 'end':
										return _context.stop();
								}
							}
						}, _callee, _this);
					})(), 't0', 22);

				case 22:
					_context2.next = 24;
					return _get__('race')({
						fetchResult: _get__('call')(_get__('doFetch'), fetchConfig),
						timedOut: _get__('call')(_get__('delay'), action.timeLimit ? action.timeLimit : 3000)
					});

				case 24:
					_ref = _context2.sent;
					fetchResult = _ref.fetchResult;
					timedOut = _ref.timedOut;

					if (!(fetchResult && !(fetchResult.title && fetchResult.title === 'Error'))) {
						_context2.next = 32;
						break;
					}

					_context2.next = 30;
					return _get__('put')(_get__('createAction')(action.noStore ? _get__('actions').TRANSIENT_FETCH_RESULT_RECEIVED : _get__('actions').FETCH_RESULT_RECEIVED, {
						data: fetchResult,
						modelName: action.modelName
					}));

				case 30:
					_context2.next = 40;
					break;

				case 32:
					if (!timedOut) {
						_context2.next = 37;
						break;
					}

					_context2.next = 35;
					return _get__('put')(_get__('createAction')(_get__('actions').FETCH_TIMED_OUT, {
						modelName: action.modelName
					}));

				case 35:
					_context2.next = 40;
					break;

				case 37:
					_context2.next = 39;
					return _get__('put')(_get__('createAction')(_get__('actions').FETCH_TRY_FAILED, {
						modelName: action.modelName,
						errorData: fetchResult
					}));

				case 39:
					throw new Error();

				case 40:
					_context2.next = 50;
					break;

				case 42:
					_context2.prev = 42;
					_context2.t1 = _context2['catch'](8);

					didFail = true;
					lastError = _context2.t1;
					_get__('logger').log('fetchData fail');
					_get__('logger').log(_context2.t1);
					_context2.next = 50;
					return _get__('call')(_get__('delay'), 2 ^ tryCount * 100);

				case 50:
					if (tryCount < tryLimit && didFail) {
						_context2.next = 6;
						break;
					}

				case 51:
					if (!(tryCount === tryLimit && didFail)) {
						_context2.next = 56;
						break;
					}

					_context2.next = 54;
					return _get__('put')(_get__('createAction')(_get__('actions').FETCH_FAILED, { modelName: action.modelName }));

				case 54:
					_get__('logger').log('fetchData retry fail');
					_get__('logger').log(lastError);

				case 56:
				case 'end':
					return _context2.stop();
			}
		}
	}, _marked[0], this, [[8, 42]]);
}

/**
 * Call the fetchData saga exactly one time (keeping in mind fetchData has retries by default)
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchOnce(action) {
	return _regenerator2.default.wrap(function fetchOnce$(_context3) {
		while (1) {
			switch (_context3.prev = _context3.next) {
				case 0:
					_context3.next = 2;
					return _get__('call')(_get__('fetchData'), action);

				case 2:
				case 'end':
					return _context3.stop();
			}
		}
	}, _marked[1], this);
}

/**
 * The loop saga that makes the request every {config.period} milliseconds until
 * cancelled
 * 
 * @param {FetchAction} action - An action with the request configuration
 */
function fetchDataLoop(action) {
	return _regenerator2.default.wrap(function fetchDataLoop$(_context4) {
		while (1) {
			switch (_context4.prev = _context4.next) {
				case 0:
					_context4.prev = 0;

				case 1:
					if (!true) {
						_context4.next = 8;
						break;
					}

					_context4.next = 4;
					return _get__('call')(_get__('fetchData'), action);

				case 4:
					_context4.next = 6;
					return _get__('call')(_get__('delay'), action.period);

				case 6:
					_context4.next = 1;
					break;

				case 8:
					_context4.prev = 8;

					_get__('put')(_get__('actions').PERIODIC_TERMINATION_SUCCEEDED);
					return _context4.finish(8);

				case 11:
				case 'end':
					return _context4.stop();
			}
		}
	}, _marked[2], this, [[0,, 8, 11]]);
}

/**
 * Call the fetchData saga every {config.period} milliseconds. This saga requires the 'period' and 'taskId' properties
 * on the action parameter.
 * 
 * @param {FetchAction} action - An action with the request configuration 
 */
function fetchDataRecurring(action) {
	var bgSyncTask;
	return _regenerator2.default.wrap(function fetchDataRecurring$(_context5) {
		while (1) {
			switch (_context5.prev = _context5.next) {
				case 0:
					if (action.period) {
						_context5.next = 2;
						break;
					}

					throw new Error("'period' config parameter is required for fetchDataRecurring");

				case 2:
					if (action.taskId) {
						_context5.next = 4;
						break;
					}

					throw new Error("'taskId' config parameter is required for fetchDataRecurring");

				case 4:
					_context5.next = 6;
					return _get__('fork')(_get__('fetchDataLoop'), action);

				case 6:
					bgSyncTask = _context5.sent;
					_context5.next = 9;
					return _get__('take')(function (action) {
						return action.type === _get__('actions').PERIODIC_TERMINATION_REQUESTED && action.taskId === action.taskId;
					});

				case 9:
					_context5.next = 11;
					return _get__('cancel')(bgSyncTask);

				case 11:
				case 'end':
					return _context5.stop();
			}
		}
	}, _marked[3], this);
}

/**
 * Call the fetchData saga, ensuring that any concurrent requests are handled and only the last one is acted on
 * 
 * @param {FetchAction} action - An action with the request configuration 
 */
function fetchLatest(action) {
	return _regenerator2.default.wrap(function fetchLatest$(_context6) {
		while (1) {
			switch (_context6.prev = _context6.next) {
				case 0:
					_context6.next = 2;
					return _get__('call')(_get__('fetchData'), action);

				case 2:
				case 'end':
					return _context6.stop();
			}
		}
	}, _marked[4], this);
}

/**
 * Function to save an oAuth token when it is receieved via a token success action
 * Token is stored and sent in all subsequent requests via Authorization headers.
 * The oAuth token is stored in memory but not in redux.
 * 
 * @param {TokenSuccessAction} action - The action containing the oAuth token
 */
function interceptOauthToken(action) {
	return _regenerator2.default.wrap(function interceptOauthToken$(_context7) {
		while (1) {
			switch (_context7.prev = _context7.next) {
				case 0:
					_assign__('oauthToken', action.oauthToken);

				case 1:
				case 'end':
					return _context7.stop();
			}
		}
	}, _marked[5], this);
}

/**
 * A default logger function that logs to the console. Used if no other logger is provided
 * 
 * @param {string} message - The message to log
 */
var consoleLogger = function consoleLogger(message) {
	console.log(message);
};

/**
 * The main saga for fetching data. Must be initialized with an object representing the models that can be fetched
 * and an API root to prepend to any partial URLs specified in the models object. A logger should normally be provided
 * as well.
 * 
 * Models object require a form as follows (with optional nested models):
 * {
 * 	fryModel: {
 * 		path: '/api/Foo'
 * 	},
 * 	groupOfModels: {
 * 		leelaModel: {
 * 			path: '/api/Bar'
 * 		},
 * 		benderModel: {
 * 			path: '/api/Baz'
 * 		}
 * 	}
 * }
 * 
 * Models are referenced in the actions.DATA_REQUESTED action by path, i.e.
 * { type: actions.DATA_REQUESTED, { modelName: 'fryModel' } }
 * -- or --
 * { type: actions.DATA_REQUESTED, { modelName: 'groupOfModels.leelaModel' } }
 * 
 * @export
 * @param {Object} modelsParam - An object indicating the APIs available in a application with which to make requests
 * @param {string} apiRootParam - A url to which partial URLs are appended (i.e.) 'https://myapp.com'
 * @param {LoggerFunction} [loggerParam=consoleLogger] - A function that accepts a string and logs it real good
 */
function fetchSaga(modelsParam, apiRootParam) {
	var loggerParam = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _get__('consoleLogger');
	return _regenerator2.default.wrap(function fetchSaga$(_context8) {
		while (1) {
			switch (_context8.prev = _context8.next) {
				case 0:
					if (modelsParam) {
						_context8.next = 2;
						break;
					}

					throw new Error("'modelsParam' is required for fetchSaga");

				case 2:
					_get__('setApiRoot')(apiRootParam);
					_assign__('logger', loggerParam);
					_assign__('models', modelsParam);

					_context8.next = 7;
					return _get__('takeEvery')(_get__('actions').DATA_REQUESTED, _get__('fetchOnce'));

				case 7:
					_context8.next = 9;
					return _get__('takeEvery')(_get__('actions').PERIODIC_DATA_REQUESTED, _get__('fetchDataRecurring'));

				case 9:
					_context8.next = 11;
					return _get__('takeLatest')(_get__('actions').DATA_REQUESTED_USE_LATEST, _get__('fetchLatest'));

				case 11:
					_context8.next = 13;
					return _get__('takeLatest')('auth/GET_TOKEN_SUCCEEDED', _get__('interceptOauthToken'));

				case 13:
					_context8.next = 15;
					return _get__('takeLatest')('auth/TOKEN_REFRESH_SUCCEEDED', _get__('interceptOauthToken'));

				case 15:
				case 'end':
					return _context8.stop();
			}
		}
	}, _marked[6], this);
}

function _getGlobalObject() {
	try {
		if (!!global) {
			return global;
		}
	} catch (e) {
		try {
			if (!!window) {
				return window;
			}
		} catch (e) {
			return this;
		}
	}
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
	if (_RewireModuleId__ === null) {
		var globalVariable = _getGlobalObject();

		if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
			globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
		}

		_RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
	}

	return _RewireModuleId__;
}

function _getRewireRegistry__() {
	var theGlobalVariable = _getGlobalObject();

	if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
		theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
	}

	return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
	var moduleId = _getRewireModuleId__();

	var registry = _getRewireRegistry__();

	var rewireData = registry[moduleId];

	if (!rewireData) {
		registry[moduleId] = Object.create(null);
		rewireData = registry[moduleId];
	}

	return rewireData;
}

(function registerResetAll() {
	var theGlobalVariable = _getGlobalObject();

	if (!theGlobalVariable['__rewire_reset_all__']) {
		theGlobalVariable['__rewire_reset_all__'] = function () {
			theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
		};
	}
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
	function addPropertyToAPIObject(name, value) {
		Object.defineProperty(_RewireAPI__, name, {
			value: value,
			enumerable: false,
			configurable: true
		});
	}

	addPropertyToAPIObject('__get__', _get__);
	addPropertyToAPIObject('__GetDependency__', _get__);
	addPropertyToAPIObject('__Rewire__', _set__);
	addPropertyToAPIObject('__set__', _set__);
	addPropertyToAPIObject('__reset__', _reset__);
	addPropertyToAPIObject('__ResetDependency__', _reset__);
	addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
	var rewireData = _getRewiredData__();

	if (rewireData[variableName] === undefined) {
		return _get_original__(variableName);
	} else {
		var value = rewireData[variableName];

		if (value === INTENTIONAL_UNDEFINED) {
			return undefined;
		} else {
			return value;
		}
	}
}

function _get_original__(variableName) {
	switch (variableName) {
		case 'put':
			return _effects.put;

		case 'createAction':
			return _actions.createAction;

		case 'actions':
			return _actions2.default;

		case '_':
			return _lodash2.default;

		case 'models':
			return models;

		case 'oauthToken':
			return oauthToken;

		case 'select':
			return _effects.select;

		case 'race':
			return _effects.race;

		case 'call':
			return _effects.call;

		case 'doFetch':
			return _fetchService.doFetch;

		case 'delay':
			return _reduxSaga.delay;

		case 'logger':
			return logger;

		case 'fetchData':
			return fetchData;

		case 'fork':
			return _effects.fork;

		case 'fetchDataLoop':
			return fetchDataLoop;

		case 'take':
			return _effects.take;

		case 'cancel':
			return _effects.cancel;

		case 'consoleLogger':
			return consoleLogger;

		case 'setApiRoot':
			return _fetchService.setApiRoot;

		case 'takeEvery':
			return _effects.takeEvery;

		case 'fetchOnce':
			return fetchOnce;

		case 'fetchDataRecurring':
			return fetchDataRecurring;

		case 'takeLatest':
			return _effects.takeLatest;

		case 'fetchLatest':
			return fetchLatest;

		case 'interceptOauthToken':
			return interceptOauthToken;
	}

	return undefined;
}

function _assign__(variableName, value) {
	var rewireData = _getRewiredData__();

	if (rewireData[variableName] === undefined) {
		return _set_original__(variableName, value);
	} else {
		return rewireData[variableName] = value;
	}
}

function _set_original__(variableName, _value) {
	switch (variableName) {
		case 'oauthToken':
			return oauthToken = _value;

		case 'logger':
			return logger = _value;

		case 'models':
			return models = _value;
	}

	return undefined;
}

function _update_operation__(operation, variableName, prefix) {
	var oldValue = _get__(variableName);

	var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

	_assign__(variableName, newValue);

	return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
	var rewireData = _getRewiredData__();

	if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
		Object.keys(variableName).forEach(function (name) {
			rewireData[name] = variableName[name];
		});
	} else {
		if (value === undefined) {
			rewireData[variableName] = INTENTIONAL_UNDEFINED;
		} else {
			rewireData[variableName] = value;
		}

		return function () {
			_reset__(variableName);
		};
	}
}

function _reset__(variableName) {
	var rewireData = _getRewiredData__();

	delete rewireData[variableName];

	if (Object.keys(rewireData).length == 0) {
		delete _getRewireRegistry__()[_getRewireModuleId__];
	}

	;
}

function _with__(object) {
	var rewireData = _getRewiredData__();

	var rewiredVariableNames = Object.keys(object);
	var previousValues = {};

	function reset() {
		rewiredVariableNames.forEach(function (variableName) {
			rewireData[variableName] = previousValues[variableName];
		});
	}

	return function (callback) {
		rewiredVariableNames.forEach(function (variableName) {
			previousValues[variableName] = rewireData[variableName];
			rewireData[variableName] = object[variableName];
		});
		var result = callback();

		if (!!result && typeof result.then == 'function') {
			result.then(reset).catch(reset);
		} else {
			reset();
		}

		return result;
	};
}

var _typeOfOriginalExport = typeof fetchSaga === 'undefined' ? 'undefined' : _typeof(fetchSaga);

function addNonEnumerableProperty(name, value) {
	Object.defineProperty(fetchSaga, name, {
		value: value,
		enumerable: false,
		configurable: true
	});
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(fetchSaga)) {
	addNonEnumerableProperty('__get__', _get__);
	addNonEnumerableProperty('__GetDependency__', _get__);
	addNonEnumerableProperty('__Rewire__', _set__);
	addNonEnumerableProperty('__set__', _set__);
	addNonEnumerableProperty('__reset__', _reset__);
	addNonEnumerableProperty('__ResetDependency__', _reset__);
	addNonEnumerableProperty('__with__', _with__);
	addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;